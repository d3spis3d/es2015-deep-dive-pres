doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title ES2015 Deep Dive

    link(rel='stylesheet', type='text/css', href='build/build.css')

  body

    article

      section
        h1 ES2015 & ES2016
        h1.bullet Deep Dive
        ul
          li a.k.a ES6 & ES7

      section
        h1.bullet Topics
        ul.bigger-list
          li New ES2015 Language Features
          li Coming ES2016 Language Features
          li Focus on stuff we can use every day
          li Exciting stuff to look forward to

      section
        h1.bullet ES?
        ul.bigger-list
          li EcmaScript
          li JavaScript is an implementation of ES
          li ES5 in 2009 -> ES2015 in June 2015
          li New spec every year

      section
        h1.bullet ES Stages
        ul.bigger-list
          li Stage 0: just an idea
          li Stage 1: formal proposal
          li Stage 2: draft spec
          li Stage 3: candidate spec
          li Stage 4: finished spec, two implementations

      section
        h1 Babel.js
        h3.bullet Babel is built on plugins, different plugins for each feature
        ul.bigger-list
          li Features can be enabled by stage
          li Or selected language features enabled individually

      section
        h1 ES2015 Features
        ul
          li
            p arrow functions, classes, enhanced object literals, template strings, destructuring, default args, rest, spread, let, const, iterators, generators, modules, Map, Set, proxies, symbols, Promises, reflect API, tail calls

      section(data-bespoke-hash="let")
        h1 Let
        h3.bullet How does #[span.token.keyword var]'s scoping work?
        ul
          li #[span.token.keyword var] is function scoped
          li Variable declarations with #[span.token.keyword var] are hoisted by the JS engine

      section
        h1 Var
        pre
          code.language-javascript.
            function() {
              a = 2;
              var a;
              console.log(a);
            }

      section
        h1 Var
        pre
          code.language-javascript.
            function() {
              var a;
              a = 2;
              console.log(a); // 2
            }

      section
        h1 Var
        pre
          code.language-javascript.
            function() {
              if (false) {
                var a = 2;
              }
              console.log(a); // Reference error?
            }

      section
        h1 Var
        pre
          code.language-javascript.
            function() {
              var a;
              if (false) {
                a = 2;
              }
              console.log(a); // undefined
            }

      section
        h1 Let
        h3.bullet #[span.token.keyword var] is function scoped
        ul
          li
            h3 #[span.token.keyword let] is block scoped
          li
            h3 A block is any pair of { }

      section
        h1 Let
        pre
          code.language-javascript.
            function() {
              let a = 2;
              {
                let a = 3;
                console.log(a); // 3
              }
              console.log(a); // 2
            }

      section
        h1 Let - Why?
        h3.bullet Principle of Least Privilege
        ul
          li
            h3 If a variable is not used outside of a block of code, don't expose it

      section
        h1 Let - Gotchas
        ul.bullet
          li
            h3 #[span.token.keyword let] is not hoisted like #[span.token.keyword var]
          li
            h3 Because of the way Babel transpiles let, let is hoisted when using Babel

      section
        h1 Let - Babel

      section(data-bespoke-hash="const")
        h1 Const
        h3.bullet Declares a variable as a constant
        ul
          li
            h3 Block scoped same as #[span.token.keyword let]
          li
            h3 Can't share its name with variable or function in the same scope

      section
        h1 Const
        pre
          code.language-javascript.
            const VAL = 12345;
            const STR = "a constant string";
            const VALUES = [1, 2, 3, 4];
            const MY_OBJECT = {
              key1: 'value'
            };

      section
        h1 Const - Gotchas
        h3.bullet Reassigning will fail silently in some browsers
        ul
          li
            h3 Important to use static analysis tools, e.g. ESLint
          li
            h3 #[span.token.keyword const] is not reassignable, but it is mutable

      section
        h1 Const - Mutable
        pre
          code.language-javascript.
            const MY_OBJECT = {
              key1: 'value';
            }
            // Change key values
            MY_OBJECT.key1 = 'otherValue';
            //Add new keys
            MY_OBJECT.key2 = 'value';

      section(data-bespoke-hash="short-obj")
        h2 Shorthand object syntax
        pre
          code.language-javascript.
            let obj = {
              // shorthand for attr: attr,
              attr,
              // shorthand for method: function() {...}
              method() {
                return 42;
              }
            };

      section(data-bespoke-hash="templ-str")
        h1 Template Strings
        h3.bullet New string syntax using #[span.token.keyword ``]
        ul
          li
            h3 Gives us:
          li
            h3 String interpolation
          li
            h3 Easy multiline strings

      section
        h1 String interpolation
        h3 Available in many other languages, Python, Perl, Ruby
        pre
          code.language-javascript.
            let name = 'Dan'; let age = '27';
            // let string = 'Hi Im ' + name + ', and Im ' + age + ' years old'
            let string = `Hi Im ${name}, and Im ${age} years old`;

      section
        h1 Multiline strings
        pre
          code.language-javascript.
            let str = `This is a
            multiline string`;


      section(data-bespoke-hash="def-args")
        h1 Default Arguments
        h3.bullet Specify default values for function arguments
        ul
          li
            h3 Used when no argument is passed in
          li
            h3 Or when the argument is undefined

      section
        h1 Default Arguments
        pre
          code.language-javascript.
            function add(x=0, y=0) {
              return x + y;
            }
            add(1); // 1
            add(undefined, 1); // 1

      section(data-bespoke-hash="destruct")
        h1 Destructuring
        h3 Automatically breaks up arrays and objects for assignment of their contents

      section
        h2 Destructuring - Arrays
        pre
          code.language-javascript.
            // without destructuring
            let nums = [0, 1, 2];
            let zero = nums[0];
            let one = nums[1];
            let two = nums[2];

      section
        h2 Destructuring - Arrays
        pre
          code.language-javascript.
            // with destructuring
            let nums = [0, 1, 2];
            let [zero, one, two] = nums;

      section
        h2 Destructuring - Objects
        pre
          code.language-javascript.
            // without
            let obj = { value: 100, word: 'hundred'};
            let value = obj.value;
            let word = obj.word;

      section
        h2 Destructuring - Objects
        pre
          code.language-javascript.
            // with
            let obj = { value: 100, word: 'hundred'};
            let {value, word} = obj;

      section
        h2 Destructuring - Objects
        pre
          code.language-javascript.
            // alternative
            let obj = { value: 100, word: 'hundred'};
            let { value: num, word: letters} = obj;
            console.log(num, letters); // 100 hundred

      section(data-bespoke-hash="spread")
        h1 Spread
        h3 A new operator #[span.token.keyword ...] that takes an array and separates into its individual values

      section
        h2 Concatenating arrays - ES5
        pre
          code.language-javascript.
            var x = [0, 1];
            var y = [2, 3];
            Array.prototype.push.apply(x, y);
            console.log(x); // [0, 1, 2, 3]

      section
        h2 Concatenating arrays - Spread
        pre
          code.language-javascript.
            var x = [0, 1];
            var y = [2, 3];
            x.push(...y);
            console.log(x); // [0, 1, 2, 3]

      section(data-bespoke-hash="rest")
        h1 Rest
        h3.bullet Is in some ways the reverse of spread
        ul
          li
            h3 Uses the same operator, but captures multiple arguments of a function into an array

      section
        h1 Rest
        pre
          code.language-javascript.
            function rest(first, ...others) {
              console.log(first, others);
            }
            rest(1, 2, 3, 4);  // 1 [2, 3, 4]

      section
        h1 Arguments
        h3.bullet Each function has access to a builtin variable #[span.token.keyword arguments]
        ul
          li
            h3 It is an Array-like object containing all the arguments passes in to the function
          li
            h3 Rest operator aims to be a more flexible replacement to #[span.token.keyword arguments]

      section
        h1 Arguments
        pre
          code.language-javascript.
            function args() {
              console.log(arguments);
            }
            args(1, '2', {}); //  { '0': 1, '1': '2', '2': {} }

      section(data-bespoke-hash="arrow")
        h1 Arrow functions
        h3.bullet New type of anonymous function
        ul
          li
            h3 Automatically binds the #[span.token.keyword this] context from the current lexical scope
          li
            h3 Also provides a cleaner syntax for anonymous functions

      section
        h1 Unbound this
        pre
          code.language-javascript.
            function($rootScope) {
              this.name = 'Dan';
              $rootScope.$on('meeting', function() {
                console.log('Hi Im ' + this.name);
              });
            }

      section
        h2 Poorly bound this
        pre
          code.language-javascript.
            function($rootScope) {
              this.name = 'Dan';
              let that = this;
              $rootScope.$on('meeting', function() {
                console.log('Hi Im ' + that.name);
              });
            }

      section
        h1 Bound this
        pre
          code.language-javascript.
            function($rootScope) {
              this.name = 'Dan';
              function meet() {
                console.log('Hi Im ' + this.name);
              }
              $rootScope.$on('meeting', meet.bind(this));
            }

      section
        h1 Arrow functions
        pre
          code.language-javascript.
            function($rootScope) {
              this.name = 'Dan';
              $rootScope.$on('meeting', () => {
                console.log('Hi Im ' + this.name);
              });
            }

      section
        h1 Arrow functions
        h3.bullet Syntax supports two forms of function body
        ul
          li
            h3 Block bodies
          li
            h3 Expression bodies

      section
        h2 Arrow functions - Expression bodies
        pre
          code.language-javascript.
            // ES5
            let a = array.map(function(x) {
              return x * x;
            });
            // arrow function with expression body
            let b = array.map(x => x * x);
            // equivalent to
            let c = array.map(x => { return x * x; });

      section
        h1.bullet Arrow functions - Gotchas
        ul
          li
            h3 Arrow functions do not have their own arguments object
          li
            h3 To return an object wrap it in parentheses
          li
            pre
              code.language-javascript.
                var a = () => ({ x: 1 });

      section(data-bespoke-hash="class")
        h1 Class
          h3.bullet Classes have existed in JavaScript as a design pattern for some time
          ul
            li
              h3 But JS does not have classes, just class-like constructor functions
            li
              h3 JS uses a prototype-based inheritance system, rather than class-based inheritance
            li
              h3 ES2015 #[span.token.keyword class] is mostly syntactic sugar on this design pattern

      section
        h1 ES5 Class
        pre
          code.language-javascript.
            // constructor function
            function Point(x, y) {
              this.x = x;
              this.y = y;
            }
            // class methods
            Point.prototype.print = function() {
              console.log(this.x + ', ' + this.y);
            }

      section
        h1 ES2015 Class
        pre
          code.language-javascript.
            class Point {
              constructor(x, y) {
                this.x = x;
                this.y = y;
              }
              print() {
                console.log(`${this.x}, ${this.y}`);
              }
            }

      section
        h1 Differences
          h3.bullet There are some differences between #[span.token.keyword class] Point and #[span.token.keyword function] Point()
          ul
            li
              h3 #[span.token.keyword class] Point can only called using #[span.token.keyword new]
            li
              h3 #[span.token.keyword class] declarations are not hoisted like #[span.token.keyword function]

      section
        h1 Subclassing
        h3.bullet The new #[span.token.keyword class] syntax supports subclassing using #[span.token.keyword extends]
        ul
          li
            h3 This also introduces #[span.token.keyword super] for calling the base class constructor/methods

      section
        h1 Base class
        pre
          code.language-javascript.
            class Point {
              constructor(x, y) {
                this.x = x; this.y = y;
              }
              print() {
                console.log(`${this.x}, ${this.y}`);
              }
            }

      section
        h1 Subclass
        pre
          code.language-javascript.
            class Point3D extends Point {
              constructor(x, y, z) {
                super(x, y);
                this.z = z;
              }
              print() {
                console.log(`${this.x}, ${this.y}, ${this.z}`);
              }
            }

      section
        h1 Class
        pre
          code.language-javascript.
            let point = new Point3D(1, 2, 3);
            point.x; // 1
            point.y; // 2
            point.z; // 3
            point.print(); // 1, 2, 3
            point instanceof Point3D; // true
            point instanceof Point; // true

      section(data-bespoke-hash="modules")
        h1 Modules

      section(data-bespoke-hash="promises")
        h1 Promises

      section(data-bespoke-hash="generators")
        h1 Generators

      section(data-bespoke-hash="es2016")
        h1 ES2016 and beyond
        h3 Best to look at the ES proposals based on current stage

      section(data-bespoke-hash="stage4")
        h1 Stage 4
        p Array.prototype.includes

      section(data-bespoke-hash="includes")
        h1 Includes
        h3.bullet Seeks to replace #[span.token.keyword indexOf] for arrays
        ul
          li
            h3 #[span.token.keyword indexOf] fails to "say what you mean"
          li
            h3 #[span.token.keyword indexOf] also fails to find #[span.token.keyword NaN] because of strict equality

      section
        h1 Includes
        pre
          code.language-javascript.
            [1, 2, 3, 5].includes(4); // false
            [NaN, 2, 3, 5].includes(NaN); // true

      section(data-bespoke-hash="stage3")
        h1 Stage 3
        p Exponentiation operator, SIMD, async, Object.values/Object.entries, String padding, function parameter trailing commas

      section(data-bespoke-hash="exp")
        h1 Exponentiation
        pre
          code.language-javascript.
            let eight = Math.pow(2, 3);
            let eight2 = 2 ** 3;

      section(data-bespoke-hash="async")
        h1 Async

      section(data-bespoke-hash="stage2")
        h1 Stage 2
        p function.sent, rest/spread objects

      section(data-bespoke-hash="stage1")
        h1 Stage 1
        p export-from, decorators, Observable, String.prototype.trimLeft/trimRight, class properties, static class properties, regex iterator, Web Worker shared memory, callable class constructors, System.global

      section(data-bespoke-hash="stage0")
        h1 Stage 0
        p const classes, Relationships, String.prototype.at, Structured Clone, weak references, Set/Map.prototype.toJSON, do expressions, Function Bind syntax, private object state









    script(src='build/build.js')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.2/ace.js')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.2/mode-javascript.js')
    script(src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.2/theme-tomorrow.js')
