<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>ES2015 Deep Dive</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section>
        <h1>ES2015 & ES2016</h1>
        <h1 class="bullet">Deep Dive</h1>
        <ul>
          <li>a.k.a ES6 & ES7</li>
        </ul>
      </section>
      <section>
        <h1 class="bullet">Topics</h1>
        <ul class="bigger-list">
          <li>New ES2015 Language Features</li>
          <li>Coming ES2016+ Language Features</li>
          <li>Focus on stuff we can use every day</li>
          <li>Exciting stuff to look forward to</li>
        </ul>
      </section>
      <section>
        <h1 class="bullet">ES?</h1>
        <ul class="bigger-list">
          <li>EcmaScript</li>
          <li>JavaScript is an implementation of ES</li>
          <li>ES5 in 2009 -> ES2015 in June 2015</li>
          <li>New spec every year</li>
        </ul>
      </section>
      <section>
        <h1 class="bullet">ES Stages</h1>
        <ul class="bigger-list">
          <li>Stage 0: just an idea</li>
          <li>Stage 1: formal proposal</li>
          <li>Stage 2: draft spec</li>
          <li>Stage 3: candidate spec</li>
          <li>Stage 4: finished spec, two implementations</li>
        </ul>
      </section>
      <section>
        <h1>Babel.js</h1>
        <h3 class="bullet">Babel is built on plugins, different plugins for each feature</h3>
        <ul class="bigger-list">
          <li>Features can be enabled by stage</li>
          <li>Or selected language features enabled individually</li>
        </ul>
      </section>
      <section>
        <h1>ES2015 Features</h1>
        <ul>
          <li>
            <p>arrow functions, classes, enhanced object literals, template strings, destructuring, default args, rest, spread, let, const, iterators, generators, modules, Map, Set, proxies, symbols, Promises, reflect API, tail calls</p>
          </li>
        </ul>
      </section>
      <section data-bespoke-hash="let">
        <h1>Let</h1>
        <h3 class="bullet">How does <span class="token keyword">var</span>'s scoping work?</h3>
        <ul>
          <li><span class="token keyword">var</span> is function scoped</li>
          <li>Variable declarations with <span class="token keyword">var</span> are hoisted by the JS engine</li>
        </ul>
      </section>
      <section>
        <h1>Var</h1>
        <pre><code class="language-javascript">function() {
  a = 2;
  var a;
  console.log(a);
}
</code></pre>
      </section>
      <section>
        <h1>Var</h1>
        <pre><code class="language-javascript">function() {
  var a;
  a = 2;
  console.log(a); // 2
}
</code></pre>
      </section>
      <section>
        <h1>Var</h1>
        <pre><code class="language-javascript">function() {
  if (false) {
    var a = 2;
  }
  console.log(a); // Reference error?
}
</code></pre>
      </section>
      <section>
        <h1>Var</h1>
        <pre><code class="language-javascript">function() {
  var a;
  if (false) {
    a = 2;
  }
  console.log(a); // undefined
}
</code></pre>
      </section>
      <section>
        <h1>Let</h1>
        <h3 class="bullet"><span class="token keyword">var</span> is function scoped</h3>
        <ul>
          <li>
            <h3><span class="token keyword">let</span> is block scoped</h3>
          </li>
          <li>
            <h3>A block is any pair of { }</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Let</h1>
        <pre><code class="language-javascript">function() {
  let a = 2;
  {
    let a = 3;
    console.log(a); // 3
  }
  console.log(a); // 2
}
</code></pre>
      </section>
      <section>
        <h1>Let - Why?</h1>
        <h3 class="bullet">Principle of Least Privilege</h3>
        <ul>
          <li>
            <h3>If a variable is not used outside of a block of code, don't expose it</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Let - Gotchas</h2>
        <ul class="bullet">
          <li>
            <h3><span class="token keyword">let</span> is not hoisted like <span class="token keyword">var</span></h3>
          </li>
          <li>
            <h3>Because of the way Babel transpiles let, let is hoisted when using Babel</h3>
          </li>
        </ul>
      </section>
      <section data-bespoke-hash="const">
        <h1>Const</h1>
        <h3 class="bullet">Declares a variable as a constant</h3>
        <ul>
          <li>
            <h3>Block scoped same as <span class="token keyword">let</span></h3>
          </li>
          <li>
            <h3>Can't share its name with variable or function in the same scope</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Const</h1>
        <pre><code class="language-javascript">const VAL = 12345;
const STR = "a constant string";
const VALUES = [1, 2, 3, 4];
const MY_OBJECT = {
  key1: 'value'
};
</code></pre>
      </section>
      <section>
        <h2>Const - Gotchas</h2>
        <h3 class="bullet">Reassigning will fail silently in some browsers</h3>
        <ul>
          <li>
            <h3>Important to use static analysis tools, e.g. ESLint</h3>
          </li>
          <li>
            <h3><span class="token keyword">const</span> is not reassignable, but it is mutable</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Const - Mutable</h2>
        <pre><code class="language-javascript">const MY_OBJECT = {
  key1: 'value';
}
// Change key values
MY_OBJECT.key1 = 'otherValue';
//Add new keys
MY_OBJECT.key2 = 'value';
</code></pre>
      </section>
      <section data-bespoke-hash="short-obj">
        <h2>Shorthand object syntax</h2>
        <pre><code class="language-javascript">let obj = {
  // shorthand for attr: attr,
  attr,
  // shorthand for method: function() {...}
  method() {
    return 42;
  }
};
</code></pre>
      </section>
      <section data-bespoke-hash="templ-str">
        <h1>Template Strings</h1>
        <h3 class="bullet">New string syntax using <span class="token keyword">``</span></h3>
        <ul>
          <li>
            <h3>Gives us:</h3>
          </li>
          <li>
            <h3>String interpolation</h3>
          </li>
          <li>
            <h3>Easy multiline strings</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>String interpolation</h2>
        <h3>Available in many other languages, Python, Perl, Ruby</h3>
        <pre><code class="language-javascript">let name = 'Dan';
// let string = 'Hi Im ' + name + '.';
let string = `Hi Im ${name}.`;
</code></pre>
      </section>
      <section>
        <h1>Multiline strings</h1>
        <pre><code class="language-javascript">let str = `This is a
multiline string`;

</code></pre>
      </section>
      <section data-bespoke-hash="def-args">
        <h1>Default Arguments</h1>
        <h3 class="bullet">Specify default values for function arguments</h3>
        <ul>
          <li>
            <h3>Used when no argument is passed in</h3>
          </li>
          <li>
            <h3>Or when the argument is undefined</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Default Arguments</h1>
        <pre><code class="language-javascript">function add(x=0, y=0) {
  return x + y;
}
add(1); // 1
add(undefined, 1); // 1
</code></pre>
      </section>
      <section data-bespoke-hash="destruct">
        <h1>Destructuring</h1>
        <h3>Automatically breaks up arrays and objects for assignment of their contents</h3>
      </section>
      <section>
        <h2>Destructuring - Arrays</h2>
        <pre><code class="language-javascript">// without destructuring
let nums = [0, 1, 2];
let zero = nums[0];
let one = nums[1];
let two = nums[2];
</code></pre>
      </section>
      <section>
        <h2>Destructuring - Arrays</h2>
        <pre><code class="language-javascript">// with destructuring
let nums = [0, 1, 2];
let [zero, one, two] = nums;
</code></pre>
      </section>
      <section>
        <h2>Destructuring - Objects</h2>
        <pre><code class="language-javascript">// without
let obj = { value: 100, word: 'hundred'};
let value = obj.value;
let word = obj.word;
</code></pre>
      </section>
      <section>
        <h2>Destructuring - Objects</h2>
        <pre><code class="language-javascript">// with
let obj = { value: 100, word: 'hundred'};
let {value, word} = obj;
</code></pre>
      </section>
      <section>
        <h2>Destructuring - Objects</h2>
        <pre><code class="language-javascript">// alternative
let obj = { value: 100, word: 'hundred'};
let { value: num, word: letters} = obj;
console.log(num, letters); // 100 hundred
</code></pre>
      </section>
      <section data-bespoke-hash="spread">
        <h1>Spread</h1>
        <h3>A new operator <span class="token keyword">...</span> that takes an array and separates into its individual values</h3>
      </section>
      <section>
        <h2>Concatenating arrays - ES5</h2>
        <pre><code class="language-javascript">var x = [0, 1];
var y = [2, 3];
Array.prototype.push.apply(x, y);
console.log(x); // [0, 1, 2, 3]
</code></pre>
      </section>
      <section>
        <h2>Concatenating arrays - Spread</h2>
        <pre><code class="language-javascript">var x = [0, 1];
var y = [2, 3];
x.push(...y);
console.log(x); // [0, 1, 2, 3]
</code></pre>
      </section>
      <section data-bespoke-hash="rest">
        <h1>Rest</h1>
        <h3 class="bullet">Is in some ways the reverse of spread</h3>
        <ul>
          <li>
            <h3>Uses the same operator, but captures multiple arguments of a function into an array</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Rest</h1>
        <pre><code class="language-javascript">function rest(first, ...others) {
  console.log(first, others);
}
rest(1, 2, 3, 4);  // 1 [2, 3, 4]
</code></pre>
      </section>
      <section>
        <h1>Arguments</h1>
        <h3 class="bullet">Each function has access to a builtin variable <span class="token keyword">arguments</span></h3>
        <ul>
          <li>
            <h3>It is an Array-like object containing all the arguments passes in to the function</h3>
          </li>
          <li>
            <h3>Rest operator aims to be a more flexible replacement to <span class="token keyword">arguments</span></h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Arguments</h1>
        <pre><code class="language-javascript">function args() {
  console.log(arguments);
}
args(1, '2', {}); //  { '0': 1, '1': '2', '2': {} }
</code></pre>
      </section>
      <section data-bespoke-hash="arrow">
        <h1>Arrow functions</h1>
        <h3 class="bullet">New type of anonymous function</h3>
        <ul>
          <li>
            <h3>Automatically binds the <span class="token keyword">this</span> context from the current lexical scope</h3>
          </li>
          <li>
            <h3>Also provides a cleaner syntax for anonymous functions</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Unbound this</h1>
        <pre><code class="language-javascript">function($rootScope) {
  this.name = 'Dan';
  $rootScope.$on('meeting', function() {
    console.log('Hi Im ' + this.name);
  });
}
</code></pre>
      </section>
      <section>
        <h2>Poorly bound this</h2>
        <pre><code class="language-javascript">function($rootScope) {
  this.name = 'Dan';
  let that = this;
  $rootScope.$on('meeting', function() {
    console.log('Hi Im ' + that.name);
  });
}
</code></pre>
      </section>
      <section>
        <h1>Bound this</h1>
        <pre><code class="language-javascript">function($rootScope) {
  this.name = 'Dan';
  function meet() {
    console.log('Hi Im ' + this.name);
  }
  $rootScope.$on('meeting', meet.bind(this));
}
</code></pre>
      </section>
      <section>
        <h2>Arrow functions</h2>
        <pre><code class="language-javascript">function($rootScope) {
  this.name = 'Dan';
  $rootScope.$on('meeting', () => {
    console.log('Hi Im ' + this.name);
  });
}
</code></pre>
      </section>
      <section>
        <h1>Arrow functions</h1>
        <h3 class="bullet">Syntax supports two forms of function body</h3>
        <ul>
          <li>
            <h3>Block bodies</h3>
          </li>
          <li>
            <h3>Expression bodies</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Arrow functions - Expression bodies</h2>
        <pre><code class="language-javascript">// ES5
let a = array.map(function(x) {
  return x * x;
});
// arrow function with expression body
let b = array.map(x => x * x);
// equivalent to
let c = array.map(x => { return x * x; });
</code></pre>
      </section>
      <section>
        <h2 class="bullet">Arrow functions - Gotchas</h2>
        <ul>
          <li>
            <h3>Arrow functions do not have their own arguments object</h3>
          </li>
          <li>
            <h3>To return an object wrap it in parentheses</h3>
          </li>
          <li>
            <pre><code class="language-javascript">var a = () => ({ x: 1 });
</code></pre>
          </li>
        </ul>
      </section>
      <section data-bespoke-hash="class">
        <h1>Class
          <h3 class="bullet">Classes have existed in JavaScript as a design pattern for some time</h3>
          <ul>
            <li>
              <h3>But JS does not have classes, just class-like constructor functions</h3>
            </li>
            <li>
              <h3>JS uses a prototype-based inheritance system, rather than class-based inheritance</h3>
            </li>
            <li>
              <h3>ES2015 <span class="token keyword">class</span> is mostly syntactic sugar on this design pattern</h3>
            </li>
          </ul>
        </h1>
      </section>
      <section>
        <h2>ES5 Class</h2>
        <pre><code class="language-javascript">// constructor function
function Point(x, y) {
  this.x = x;
  this.y = y;
}
// class methods
Point.prototype.print = function() {
  console.log(this.x + ', ' + this.y);
}
</code></pre>
      </section>
      <section>
        <h2>ES2015 Class</h2>
        <pre><code class="language-javascript">class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  print() {
    console.log(`${this.x}, ${this.y}`);
  }
}
</code></pre>
      </section>
      <section>
        <h1>Differences
          <h3 class="bullet">There are some differences between <span class="token keyword">class</span> Point and <span class="token keyword">function</span> Point()</h3>
          <ul>
            <li>
              <h3><span class="token keyword">class</span> Point can only called using <span class="token keyword">new</span></h3>
            </li>
            <li>
              <h3><span class="token keyword">class</span> declarations are not hoisted like <span class="token keyword">function</span></h3>
            </li>
          </ul>
        </h1>
      </section>
      <section>
        <h1>Subclassing</h1>
        <h3 class="bullet">The new <span class="token keyword">class</span> syntax supports subclassing using <span class="token keyword">extends</span></h3>
        <ul>
          <li>
            <h3>This also introduces <span class="token keyword">super</span> for calling the base class constructor/methods</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Base class</h2>
        <pre><code class="language-javascript">class Point {
  constructor(x, y) {
    this.x = x; this.y = y;
  }
  print() {
    console.log(`${this.x}, ${this.y}`);
  }
}
</code></pre>
      </section>
      <section>
        <h2>Subclass</h2>
        <pre><code class="language-javascript">class Point3D extends Point {
  constructor(x, y, z) {
    super(x, y);
    this.z = z;
  }
  print() {
    console.log(`${this.x}, ${this.y}, ${this.z}`);
  }
}
</code></pre>
      </section>
      <section>
        <h1>Class</h1>
        <pre><code class="language-javascript">let point = new Point3D(1, 2, 3);
point.x; // 1
point.y; // 2
point.z; // 3
point.print(); // 1, 2, 3
point instanceof Point3D; // true
point instanceof Point; // true
</code></pre>
      </section>
      <section data-bespoke-hash="modules">
        <h1>Modules</h1>
        <h3 class="bullet">JavaScript has no built-in module system</h3>
        <ul>
          <li>
            <h3>Two standards for modules have developed from the JS community</h3>
          </li>
          <li>
            <h3>CommonJS modules</h3>
          </li>
          <li>
            <h3>AMD modules</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>CommonJS modules</h2>
        <h3 class="bullet">Synchronous loading modules</h3>
        <ul>
          <li>
            <h3>Originally used server-side</h3>
          </li>
          <li>
            <h3>Dominant implementation is Node.js modules</h3>
          </li>
          <li>
            <h3>Recently moving to the browser with tools like Browserify, Webpack</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>CommonJS modules</h2>
        <pre><code class="language-javascript">// math.js
var square = function(x) { return x*x; };
var pi = 3.14159526;
module.exports = {
  square: square,
  pi: pi
};
// elsewhere
var math = require('math.js');
console.log(math.square(math.pi)); // 9.8696207
</code></pre>
      </section>
      <section>
        <h1>AMD modules</h1>
        <h3 class="bullet">Asynchronous loading modules</h3>
        <ul>
          <li>
            <h3>Designed for the browser</h3>
          </li>
          <li>
            <h3>Dominant implementation is RequireJS modules</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>RequireJS modules</h2>
        <pre><code class="language-javascript">define([
  'jquery',
  'backbone',
  'metrics',
  "modules/session"
],
function($, Backbone, Metrics, Session) {
  ...
});
</code></pre>
      </section>
      <section>
        <h2>ES2015 Modules</h2>
        <h3 class="bullet">Aim to provide the benefits of both standards, and none of the drawbacks</h3>
        <ul>
          <li>
            <h3>Support for synchronous and asynchronous loading</h3>
          </li>
          <li>
            <h3>Compact CommonJS-like syntax</h3>
          </li>
          <li>
            <h3>Support for static analysis and cyclic dependencies</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>ES2015 Modules</h2>
        <h3 class="bullet">When creating modules there are two different kinds of exports</h3>
        <ul>
          <li>
            <h3>Default export</h3>
          </li>
          <li>
            <h3>Named exports</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Default Export</h2>
        <pre><code class="language-javascript">// lib.js
export default function() {
  ...
}
// elsewhere
import myFunc from 'lib.js';
myFunc();
</code></pre>
      </section>
      <section>
        <h2>Named Exports</h2>
        <pre><code class="language-javascript">export var myVar = 12345;
export let myStr = 'important string';
export const pi = 3.14159526;
export function myFunc() {
  ...
}
export class myClass {
  ...
}
</code></pre>
      </section>
      <section>
        <h1>Named exports</h1>
        <pre><code class="language-javascript">import {myVar, myStr, myFunc} from 'lib.js';
</code></pre>
      </section>
      <section>
        <h1>Mixed Exports</h1>
        <pre><code class="language-javascript">// lib.js
export default function(x) { return x*x; }
export const pi = 3.14159526;
// elsewhere
import square, { pi } from 'lib.js';
</code></pre>
      </section>
      <section>
        <h2>Renaming Imports</h2>
        <pre><code class="language-javascript">import {pi as inaccuratePi} from 'lib.js';
</code></pre>
      </section>
      <section data-bespoke-hash="promises">
        <h1>Promises</h1>
        <h3 class="bullet">Promises are an approach to dealing with asynchronous computations</h3>
        <ul>
          <li>
            <h3>They provide a better approach than callback or events for asynchronous programming in JS</h3>
          </li>
          <li>
            <h3>Many Promise libraries exists, implementing a spec called Promises/A+</h3>
          </li>
          <li>
            <h3>Popular ones include Q, when, bluebird</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Promises</h1>
        <h3 class="bullet">Why do we need Promises?</h3>
        <ul>
          <li>
            <h3>Race conditions between event being triggered and event handler being added</h3>
          </li>
          <li>
            <h3>Callback hell</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Callback Hell</h1>
        <pre><code class="language-javascript">asyncFunc(function(err, data) {
  anotherAsync(data, function(err2, data2) {
    yetAnotherAsync(data2, function(err3, data3) {
      console('Im in callback hell!');
    });
  });
});
</code></pre>
      </section>
      <section>
        <h1>Promises</h1>
        <h3 class="bullet">A Promise represents the result of an asynchronous action that will eventually succeed or fail</h3>
        <ul>
          <li>
            <h3>Promises exist in one of three states, pending, fulfilled or rejected</h3>
          </li>
          <li>
            <h3>Handlers to be called on fulfillment or rejected are attached using <span class="token keyword">then</span></h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Promises</h1>
        <pre><code class="language-javascript">const p = new Promise(function(reject, resolve) {
  setTimeout(function() {
    resolve('done!');
  }, Math.random() * 5000)
});
</code></pre>
      </section>
      <section>
        <h1>Promises</h1>
        <pre><code class="language-javascript">p.then((result) => {
  console.log(result);
}, (err) => {
  console.log(err);
});
</code></pre>
      </section>
      <section>
        <h2>Promise Benefits</h2>
        <h3 class="bullet">A Promise is an object, can be passed around and have handlers attached in multiple places</h3>
        <ul>
          <li>
            <h3>If the Promise is resolved/rejected before handlers are attached they will still be run on attachment</h3>
          </li>
          <li>
            <h3>Highly composable using chaining, Promise.all, Promise.race</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Generators</h1>
        <h3 class="bullet">Whenever ever a function is executed in JS, the engine executes the whole function, top to bottom</h3>
        <ul>
          <li>
            <h3>Run-to-completion</h3>
          </li>
          <li>
            <h3>Until now..</h3>
          </li>
        </ul>
      </section>
      <section data-bespoke-hash="generators">
        <h1>Generators</h1>
        <h3 class="bullet">ES2015 defines are a new type of function</h3>
        <ul>
          <li>
            <pre><code class="language-javascript">function*() { ... }</code></pre>
          </li>
          <li>
            <h3>This is a special kind of function that returns a Generator</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Generators</h1>
        <h3 class="bullet">Generators are a special kind of iterator</h3>
        <ul>
          <li>
            <h3>Generators do not follow run-to-completion</h3>
          </li>
          <li>
            <h3>They can be paused using <span class="token keyword">yield</span> in the Generator</h3>
          </li>
          <li>
            <h3>And resumed on the outside by calling <span class="token keyword">next</span> on the Generator</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Generators</h1>
        <h3>They also allow 2 way message passing between the generator function and the calling code</h3>
      </section>
      <section>
        <h2>Generators</h2>
        <pre><code class="language-javascript">function *gen() {
  yield 1;
  yield 2;
  yield 3;
}
let it = gen();
it.next(); // {value: 1, done: false}
it.next(); // {value: 2, done: false}
it.next(); // {value: 3, done: false}
it.next(); // {value: undefined, done: true}
</code></pre>
      </section>
      <section>
        <h2>Generators</h2>
        <pre><code class="language-javascript">function *fib() {
  let x = 0, y = 1;
  while (true) {
    let t = y;
    y = x + t; x = t;
    yield y;
  }
}
</code></pre>
      </section>
      <section>
        <h2>Generators</h2>
        <pre><code class="language-javascript">for (let n of fib) {
  if (n > 1000) {
    break;
  }
  console.log(n);
}
</code></pre>
      </section>
      <section>
        <h2>Message passing</h2>
        <pre><code class="language-javascript">function *gen(x) {
  let y = yield (x * 2);
  let z = yield (y * 2);
  return z * 2;
}
let it = gen(2);
it.next().value; // 4
it.next(3).value; // 6
it.next(4).value; // 8
</code></pre>
      </section>
      <section data-bespoke-hash="es2016">
        <h1>ES2016 and beyond</h1>
        <h3>Best to look at the ES proposals based on current stage</h3>
      </section>
      <section data-bespoke-hash="stage4">
        <h1>Stage 4</h1>
        <p>Array.prototype.includes</p>
      </section>
      <section data-bespoke-hash="includes">
        <h1>Includes</h1>
        <h3 class="bullet">Seeks to replace <span class="token keyword">indexOf</span> for arrays</h3>
        <ul>
          <li>
            <h3><span class="token keyword">indexOf</span> fails to "say what you mean"</h3>
          </li>
          <li>
            <h3><span class="token keyword">indexOf</span> also fails to find <span class="token keyword">NaN</span> because of strict equality</h3>
          </li>
        </ul>
      </section>
      <section>
        <h1>Includes</h1>
        <pre><code class="language-javascript">[1, 2, 3, 5].includes(4); // false
[NaN, 2, 3, 5].includes(NaN); // true
</code></pre>
      </section>
      <section data-bespoke-hash="stage3">
        <h1>Stage 3</h1>
        <p>Exponentiation operator, SIMD, async, Object.values/Object.entries, String padding, function parameter trailing commas</p>
      </section>
      <section data-bespoke-hash="exp">
        <h1>Exponentiation</h1>
        <pre><code class="language-javascript">let eight = Math.pow(2, 3);
let eight2 = 2 ** 3;
</code></pre>
      </section>
      <section data-bespoke-hash="async">
        <h1>Async</h1>
        <h3 class="bullet">Async control flow with Promises is much better than callback</h3>
        <ul>
          <li>
            <h3>But can we do even better?</h3>
          </li>
          <li>
            <h3>With Promises + Generators we can!</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Async</h2>
        <pre><code class="language-javascript">fetch('/api/data').then((response) => {
  return response.json();
}).then((json) => {
  return data = JSON.parse(json);
}).then((data) => {
  return fetch(`/api/x/${data.id}`);
})
....
}).catch((err) => {
  console.log(err);
});
</code></pre>
      </section>
      <section>
        <h1>Async</h1>
        <h3 class="bullet">Libraries exist that allow us to use Generators to simply the structure of our code</h3>
        <ul>
          <li>
            <h3>Once such library is <a href="http://taskjs.org">Task.js</a></h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Async</h2>
        <pre><code class="language-javascript">spawn(function*() {
  try {
    let response = yield fetch('/api/data');
    let json = yield response.json();
    let data = JSON.parse(json);
    let resp2 = yield fetch(`/api/x/${data.id}`);
    ...
  } catch (err) {
    console.log(err);
  }
});
</code></pre>
      </section>
      <section>
        <h1>Async</h1>
        <h3 class="bullet">The async proposal adds this pattern into JS with new keywords:</h3>
        <ul>
          <li>
            <h3><span class="token keyword">async function</span></h3>
          </li>
          <li>
            <h3><span class="token keyword">await</span></h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Async</h2>
        <pre><code class="language-javascript">async function() {
  try {
    let response = await fetch('/api/data');
    let json = await response.json();
    let data = JSON.parse(json);
    let resp2 = await fetch(`/api/x/${data.id}`);
    ...
  } catch (err) {
    console.log(err);
  }
}

</code></pre>
      </section>
      <section data-bespoke-hash="stage2">
        <h1>Stage 2</h1>
        <p>function.sent, spread/rest objects</p>
      </section>
      <section data-bespoke-hash="o-spread">
        <h1>Object Spread</h1>
        <pre><code class="language-javascript">let x = 1;
let y = 2;
let z = {a: 3, b: 4};
let w = {x, y, ...z};
console.log(w); // {x: 1, y: 2, a: 3, b: 4}
</code></pre>
      </section>
      <section data-bespoke-hash="o-rest">
        <h1>Object Rest</h1>
        <pre><code class="language-javascript">let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4};
console.log(x); // 1
console.log(y); // 2
console.log(z); // {a: 3, b: 4}
</code></pre>
      </section>
      <section data-bespoke-hash="stage1">
        <h1>Stage 1</h1>
        <p>export-from, decorators, Observable, String.prototype.trimLeft/trimRight, class properties, static class properties, regex iterator, Web Worker shared memory, callable class constructors, System.global</p>
      </section>
      <section data-bespoke-hash="decorators">
        <h1>Decorators</h1>
        <h3 class="bullet">Decorators are higher-order functions which modify the decorated class, class property or object literal</h3>
        <ul>
          <li>
            <h3>Similar to decorators in Python</h3>
          </li>
          <li>
            <h3>Decorators use the <span class="token keyword">@</span> operator and have a name that matches the name of the decorator function</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">function readonly(target, key, descriptor) {
  descriptor.writable = false;
  return descriptor;
}
</code></pre>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">class Point {
  constructor(x, y) {
    this.x = x; this.y = y;
  }
  @readonly
  print() {
    console.log(`${this.x}, ${this.y}`);
  }
}
</code></pre>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">let p = new Point(1, 2);
p.print(); // 1, 2
p.print = () => {
  console.log(`${this.y}, ${this.x}`);
}
// Cannot assign to read only
// property 'print' of [object Object]
</code></pre>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">let o = {
  @readonly
  print() {
    console.log('my object');
  }
};
</code></pre>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">function cartesian(target) {
  target.coordinate = 'cartesian';
}
</code></pre>
      </section>
      <section>
        <h2>Decorators</h2>
        <pre><code class="language-javascript">@cartesian
class Point {
  constructor(x, y) { ... }
  print() {
    console.log(`${Point.coordinate}:
                  ${this.x}, ${this.y}`);
  }
}
let p = new Point(1, 2);
console.log(p.print()); // cartesian: 1, 2
</code></pre>
      </section>
      <section data-bespoke-hash="class-prop">
        <h2>Class properties</h2>
        <h3 class="bullet">There are a number of ES proposals that seek to build on the ES2015 class syntax</h3>
        <ul>
          <li>
            <h3>Class properties and static class properties are one such proposal</h3>
          </li>
        </ul>
      </section>
      <section>
        <h2>Class properties</h2>
        <pre><code class="language-javascript">class Point {
  coordinate = 'cartesian';
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
let p = Point(1, 2);
p.coordinate; // cartesian
</code></pre>
      </section>
      <section>
        <h2>Static properties</h2>
        <pre><code class="language-javascript">class Point {
  static coordinate = 'cartesian';
  constructor(x, y) {
    ...
  }
}
Point.coordinate; // cartesian;
</code></pre>
      </section>
      <section data-bespoke-hash="stage0">
        <h1>Stage 0</h1>
        <p>const classes, Relationships, String.prototype.at, Structured Clone, weak references, Set/Map.prototype.toJSON, do expressions, Function Bind syntax, private object state</p>
      </section>
      <section data-bespoke-hash="end">
        <h1>Thanks</h1>
        <h3>Daniel Budden</h3>
        <h3>Github: <a href="https://github.com/d3pis3d">d3spis3d</a></h3>
        <h3>Twitter: <a href="https://twitter.com/danlbudden">@danlbudden</a></h3>
        <h4><a href="http://d3spis3d.github.io/es2015-deep-dive-pres">http://d3spis3d.github.io/es2015-deep-dive-pres</a></h4>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>